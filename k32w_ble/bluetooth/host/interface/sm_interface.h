/*! *********************************************************************************
* \defgroup BLESecurityManager Security Manager
* @{
********************************************************************************** */
/*! *********************************************************************************
* Copyright (c) 2015, Freescale Semiconductor, Inc.
* Copyright 2016-2020 NXP
* All rights reserved.
*
* \file
*
* This is the header file for the BLE Security Manager Interface for
* upper layers (GAP, Application, Profiles).
*
* SPDX-License-Identifier: BSD-3-Clause
********************************************************************************** */

#ifndef SM_INTERFACE_H
#define SM_INTERFACE_H


#include "sm_params.h"
#include "smp_types.h"
#include "ble_general.h"

/************************************************************************************
*************************************************************************************
* Public type definitions
*************************************************************************************
************************************************************************************/

/*! This is the command type enumeration for the BLE Security Manager upper interface */
typedef enum
{
    gBleSmNoCommand_c                           = 0x00, /*!< No command */
    gBleSmCmdInitiatorStartPairing_c            = 0x01, /*!< Command for starting the pairing procedure as a Master (Central) device.
                                                         *     + Command payload: \ref smPairingParams_t.*/
    gBleSmCmdSendSecurityRequest_c              = 0x02, /*!< Command for sending a SMP Security Request from a Slave (Peripheral) device to a Master (Central) device.
                                                         *   Command payload: \ref smSecurityReqParams_t */
    gBleSmCmdTerminatePairing_c                 = 0x03, /*!< Command used to terminate a remotely or locally started pairing procedure. A SMP pairing failed reason is expected as a parameter.
                                                         *   Not all SMP Pairing Failed Reasons are accepted by this command. Some reasons are only internally generated by the SM or are only accepted in certain phases of the pairing procedure.
                                                         *     + Command payload: \ref smTerminatePairingParams_t */
    gBleSmCmdPairingRequestReply_c              = 0x04, /*!< Command for supplying the SM with the security parameters required for pairing after a Pairing Request has been received by a Responder
                                                         *     + Command payload: \ref smPairingParams_t
                                                         *     + Response to a \ref gBleSmEventRemotePairingRequest_c event. */
    gBleSmCmdPasskeyRequestReply_c              = 0x05, /*!< Command for supplying the SM with the requested Passkey (either decimal 0 to 999999 or 16 bytes OOB).
                                                         *   The passkey type supplied must match the type requested (otherwise the SM will return an error status).
                                                         *     + Command payload: \ref smPasskeyReqReplyParams_t
                                                         *     + Response to a \ref gBleSmEventPasskeyRequest_c event.*/
    gBleSmCmdPairingKeysetRequestReply_c        = 0x06, /*!< Command for supplying the SM with the keyset and additional data required for the Key Distribution phase of the SMP Pairing procedure.
                                                         *   The keys supplied are specified in the parameters and must match the ones requested (Otherwise the SM will return an error status).
                                                         *     + Command payload: \ref smPairingKeysetRequestReplyParams_t
                                                         *     + Response to a \ref gBleSmEventPairingKeysetRequest_c event.*/
#if (gSmpInitiatorSupported_d == 1U)
    gBleSmCmdLlStartEncryption_c                = 0x07, /*!< Command for starting the Link Layer encryption of a connections to a target device.
                                                         *   Host stack managed HCI_LE_Start_Encryption command.
                                                         *     + Command payload: \ref smLlStartEncryptionParams_t
                                                         *     + Expected response: \ref gBleSmEventLlEncryptionStatus_c */
#endif
#if (gSmpResponderSupported_d == 1)
    gBleSmCmdLlLtkRequestReply_c                = 0x08, /*!< Positive reply to a Long Term Key request from the Link Layer.
                                                         *   Host stack managed HCI_LE_Long_Term_Key_Request_Reply command.
                                                         *   If the Link layer requests the STK (EDIV and RAND are equal to 0) then the LTK request never reaches the layer above the SM.
                                                         *     + Command payload: \ref smLlLtkRequestReplyParams_t
                                                         *     + Response to a \ref gBleSmEventLlLtkRequest_c event.
                                                         *     + Expected response: \ref gBleSmEventLlEncryptionStatus_c */
    gBleSmCmdLlLtkRequestNegativeReply_c        = 0x09, /*!< Negative reply to a Long Term Key request from the Link Layer.
                                                         *   Host stack managed HCI_LE_Long_Term_Key_Request_Negative_Reply command.
                                                         *   If the Link layer requests the STK (EDIV and RAND are equal to 0) then the LTK request never reaches the layer above the SM.
                                                         *     + Command payload: none
                                                         *     + Response to a \ref gBleSmEventLlLtkRequest_c event.
                                                         *     + Expected response: \ref gBleSmEventLlEncryptionStatus_c */
#endif
#if defined(gHciLeEncryptSupport_d) && (gHciLeEncryptSupport_d == TRUE)
    gBleSmCmdLlEncryptReq_c                     = 0x0A, /*!< Encrypt a 128 bit (16 byte) block with AES-128 using a provided 128 bit key.
                                                         *   Host stack managed HCI_LE_Encrypt command.
                                                         *   The encryption will be done immediately if the SM has AES hardware support (No HCI commands will be called).
                                                         *     + Command payload: \ref smLlEncryptReqParams_t
                                                         *     + Expected response: \ref gBleSmEventLlEncryptRes_c */
#endif
#if defined(gHciLeRandomSupport_d) && (gHciLeRandomSupport_d == TRUE)
    gBleSmCmdLlRandReq_c                        = 0x0B, /*!< Generate a 64 bit (8 byte) random number.
                                                         *   Host stack managed HCI_LE_Rand command.
                                                         *   The random number will be provided immediately if the SM has RNG hardware support (No HCI commands will be called).
                                                         *     + Command payload: none
                                                         *     + Expected response: \ref gBleSmEventLlRandRes_c */
#endif
    gBleSmCmdTbCreateRandomDeviceAddrReq_c      = 0x0C, /*!< SM Tool Box: Create a BLE Random address
                                                         *     + Static Address - 48 bits (46 random), ends with 0b11
                                                         *     + Non-resolvable Private Address - 48 bits (46 random), ends with 0b00
                                                         *     + Resolvable Private Address - 48 bits (22 random + 24 bit hash), ends with 0b01. A 128 bit IRK must be provided.
                                                         *
                                                         *   The random part of the address will be available immediately if the host stack has RNG support (No HCI commands will be called).
                                                         *   The random part of a Resolvable Private Address will be generated internally if it is not provided by the upper layer (NULL pointer).
                                                         *     + Command payload: \ref smTbCreateRandomDeviceAddrReqParams_t
                                                         *     + Expected response: \ref gBleSmEventTbCreateRandomDeviceAddrRes_c */
    gBleSmCmdTbCheckResolvablePrivateAddrReq_c  = 0x0D, /*!< SM Tool Box: Verify a BLE Resolvable Private Address (48 bit) given an IRK (128 bit).
                                                         *     + Command payload: \ref smTbCheckResolvablePrivateAddrReqParams_t
                                                         *     + Expected response: \ref gBleSmEventTbCheckResolvalePrivateAddrRes_c */
#if (gGattClientSupported_d == 1)
    gBleSmCmdTbSignDataReq_c                    = 0x0E, /*!< SM Tool Box: Compute the signature for a data block of given length using a provided CSRK (128 bit).
                                                         *   The maximum acceptable data length is MAX_ATT_MTU - 8.
                                                         *     + Command payload: \ref smTbSignDataReqParams_t
                                                         *     + Expected response: \ref gBleSmEventTbSignDataRes_c */
#endif
#if (gGattServerSupported_d == 1)
    gBleSmCmdTbVerifyDataSignatureReq_c         = 0x0F, /*!< SM Tool Box: Verify the signature for a data block of given length using a provided CSRK (128 bit).
                                                         *   The maximum acceptable data length is MAX_ATT_MTU - 8.
                                                         *     + Command payload: \ref smTbVerifyDataSignatureReqParams_t
                                                         *     + Expected response: \ref gBleSmEventTbVerifyDataSignatureRes_c */
#endif
    gBleSmCmdDevConnectNotification_c           = 0x10, /*!< Command for notifying the SM that a LL connection with a specified remote device has been created.
                                                         *   This command must be sent by the upper layer which is managing LL connections every time a new connection is created.
                                                         *   The SM performs specific maintenance tasks on its internal structures when it receives this command
                                                         *     + Command payload: none */
    gBleSmCmdDevDisconnectNotification_c        = 0x11, /*!< Command for notifying the SM that a LL connection with a specified remote device has been terminated.
                                                         *   This command must be sent by the upper layer which is managing LL connections every time a connection is terminated.
                                                         *   The SM performs specific maintenance tasks on its internal structures when it receives this command.
                                                         *     + Command payload: none */
    gBleSmCmdSetDefaultPasskey_c                = 0x12, /*!< Command for setting a default passkey in the SM. This passkey is only used when during the pairing procedure
                                                         *   the current device must display a passkey. If the default passkey is set the SM will use it instead of generating a
                                                         *   random passkey.
                                                         *   If the set value is between 0 and 999.999 decimal then the SM will use it, else it will ignore it and generate a random passkey.
                                                         *     + Command payload: \ref smSetDefaultPasskeyParams_t */
#if (gBLE42_d == TRUE)
    gBleSmCmdSetOobMitmProtection_c             = 0x13, /*!< Command for setting the MITM protection property of the OOB pairing method starting with BLE 4.2.
                                                         *   The MITM protection status of the OOB can only be determined by the application.
                                                         *   In pre BLE 4.2 standards the OOB pairing method offers MITM protection by default.
                                                         *   By default the OOB pairing method does not have MITM protection.
                                                         *     + Command payload: \ref smSetOobMitmProtectionParams_t */
    gBleSmCmdSendKeypressNotification_c         = 0x14, /*!< Command for sending a Keypress Notification to a peer when pairing using the Passkey Entry pairing method.
                                                         *     + Command payload: \ref smKeypressNotificationParams_t */
    gBleSmCmdNcDisplayConfirm_c                 = 0x15, /*!< Command for sending a Numeric Comparison display confirmation when pairing using the
                                                         *   LE SC Numeric Comparison pairing method.
                                                         *     + Command payload: \ref smNcDisplayConfirmParams_t
                                                         *     + Response to a \ref gBleSmEventNcDisplayRequest_c event. */
    gBleSmCmdLeScOobDataRequestReply_c          = 0x16, /*!< Command for providing the SM with the remote LE SC OOB Data when pairing using the LE SC OOB
                                                         *   pairing method. The Application must obtain this data from a peer using an out-of-band communication method
                                                         *   and must signal that it has or can obtain this data by setting the appropriate bits in the Pairing Request
                                                         *   or Pairing Response packet.
                                                         *     + Command payload: \ref smLeScOobDataParams_t
                                                         *     + Response to a \ref gBleSmEventLeScOobDataRequest_c event. */
    gBleSmCmdLocalLeScOobDataRequest_c          = 0x17, /*!< Command for requesting from the SM the local LE SC OOB Data when pairing using the LE SC OOB pairing method.
                                                         *   The Application must obtain this data from the local SM an send it to a peer using an out-of-band
                                                         *   communication method. This data can be requested before the pairing begins or even before the devices are
                                                         *   connected through BLE. This command does not require a valid Device Id.
                                                         *     + Command payload: none
                                                         *     + Expected response: \ref gBleSmEventLocalLeScOobData_c */
    gBleSmCmdGenerateNewEcdhPkSkPairReq_c       = 0x18, /*!< Command for requesting the generating of a new ECDH Public Key - Secret Key pair in the Security Manager.
                                                         *   When this command is sent the LE SC OOB r and Cr values will be also regenerated because
                                                         *   the Public Key is used to calculate the LE SC OOB Cr value.
                                                         *     + Command payload: none
                                                         *     + Expected response: \ref gBleSmEventGenerateNewEcdhPkSkPairRes_c */
#endif /* (gBLE42_d == TRUE) */
    gBleSmCmdSetMinPairingSecurityProperties_c  = 0x19, /*!< Command for setting setting the minimum security properties resulted from the SMP Pairing Procedure
                                                         *   which will be accepted by the SM for this device (globally).
                                                         *   The default properties are: no MITM, no SC, minimum key size is the minimum accepted by the specification
                                                         *     + Command payload: \ref smSetMinPairingSecurityPropertiesParams_t */
    gBleSmCmdDHKeyComputedNotification_c        = 0x1A, /*!< Command to notify and pass the ECDH Key to SM in order to resume the pairing process
                                                         *     + Command payload: \ref computeDhKeyParam_t */
    gBleSmLastCommandCode_c                       ,     /*!< Command code used to mark the end of valid command codes. Used only for parameter validation. */
} bleSmCommand_t;

/*! This is the event type enumeration for the BLE Security Manager upper interface */
typedef enum
{
    gBleSmNoEvent_c                             = 0x00, /*!< No event */
    gBleSmEventStatus_c                         = 0x01, /*!< Event which signals an internal status of the SM which was not generated by an upper layer action.
                                                         *     + Event payload: \ref smStatusParams_t */
    gBleSmEventRemoteSecurityRequest_c          = 0x02, /*!< Event which signals that SMP Security Request has been received from a Slave (Peripheral) device. Pairing must not necessarily be started by the upper layer after this request.
                                                         *     + Event payload: \ref smSecurityReqParams_t */
    gBleSmEventRemotePairingRequest_c           = 0x03, /*!< Event which signals upper layers that a Pairing Request has been received from a Master (Central) device. Pairing parameters must be provided if the receiving device wants to continue the pairing process.
                                                         *     + Event payload \ref smPairingParams_t
                                                         *     + Expected response: \ref gBleSmCmdPairingRequestReply_c command */
    gBleSmEventRemotePairingResponse_c          = 0x04, /*!< Event which signals upper layers that a Pairing Response has been received from a Slave (Peripheral) device.
                                                         *   The receiving device can terminate the pairing procedure if the Pairing Response parameters do not meet its requirements.
                                                         *     + Event payload \ref smPairingParams_t */
    gBleSmEventPasskeyDisplayRequest_c          = 0x05, /*!< Event sent to the host by the SM to display a Passkey from 0 to 999999 which must be entered on the peer device.
                                                         *     + Event payload: \ref smPasskeyDisplayReqParams_t */
    gBleSmEventPasskeyRequest_c                 = 0x06, /*!< Event sent to the host by the SM to request a Passkey (either decimal 0 to 999999 or 16 bytes OOB). The type of passkey is specified in the event parameters.
                                                         *     + Event payload: \ref smPasskeyReqParams_t
                                                         *     + Expected response: \ref gBleSmCmdPasskeyRequestReply_c */
    gBleSmEventPairingKeysetRequest_c           = 0x07, /*!< Event sent to the host by the SM to request a pairing keyset. The keys/additional information requested are specified in the parameters.
                                                         *     + Event payload: \ref smPairingKeysetReqParams_t
                                                         *     + Expected response: \ref gBleSmCmdPairingKeysetRequestReply_c */
    gBleSmEventPairingKeysetReceived_c          = 0x08, /*!< Event sent to the host by the SM containing a pairing keyset received from a peer device during the Key Distribution phase of the SMP Pairing procedure.
                                                         *     + Event payload: \ref smPairingKeysetReceivedParams_t */
    gBleSmEventPairingComplete_c                = 0x09, /*!< Event which signals the successful completion of a SMP Pairing procedure with a peer device.
                                                         *     + Event payload: \ref smPairingCompleteParams_t */
    gBleSmEventPairingFailed_c                  = 0x0A, /*!< Event which signals a local pairing procedure failure and the reason.
                                                         *     + Event payload: \ref smPairingFailedParams_t */
    gBleSmEventRemotePairingFailed_c            = 0x0B, /*!< Event which signals a remote pairing procedure failure (a Pairing Failed packet has been received from a peer device) and the reason.
                                                         *     + Event payload: \ref smPairingFailedParams_t */
    gBleSmEventLlLtkRequest_c                   = 0x0C, /*!< An event sent when the Link layer requires the LTK from the upper layer to encrypt a link.
                                                         *     + Event payload: \ref smLlLtkRequestParams_t
                                                         *     + Expected response: \ref gBleSmCmdLlLtkRequestReply_c command
                                                         *     + Expected response: \ref gBleSmCmdLlLtkRequestNegativeReply_c command */
    gBleSmEventLlEncryptionStatus_c             = 0x0D, /*!< Status of a Link Layer encryption procedure:
                                                         *     + status: Link Layer status
                                                         *     + encryption: no change/not encrypted/encrypted/key refresh
                                                         *     + key: none/STK/LTK
                                                         *
                                                         *   This event is generated automatically by the SM when the link is encrypted during the SMP Pairing Procedure.
                                                         *     + Event payload: \ref smLlEncryptionStatusParams_t
                                                         *     + Response to a \ref gBleSmCmdLlStartEncryption_c command. */
#if defined(gHciLeEncryptSupport_d) && (gHciLeEncryptSupport_d == TRUE)
    gBleSmEventLlEncryptRes_c                   = 0x0E, /*!< 128 bit Data block encrypted (ES-128) with the provided key.
                                                         *     + Event payload: \ref smLlEncryptResParams_t
                                                         *     + Response to a \ref gBleSmCmdLlEncryptReq_c command. */
#endif
#if defined(gHciLeRandomSupport_d) && (gHciLeRandomSupport_d == TRUE)
    gBleSmEventLlRandRes_c                      = 0x0F, /*!< 64 bit random number.
                                                         *     + Event payload: \ref smLlRandResParams_t
                                                         *     + Response to a \ref gBleSmCmdLlRandReq_c command. */
#endif
    gBleSmEventTbCreateRandomDeviceAddrRes_c    = 0x10, /*!< SM Tool Box: A Random Device Address of the requested type.
                                                         *     + Event payload: \ref smTbCreateRandomDeviceAddrResParams_t
                                                         *     + Response to a \ref gBleSmCmdTbCreateRandomDeviceAddrReq_c command. */
    gBleSmEventTbCheckResolvalePrivateAddrRes_c = 0x11, /*!< SM Tool Box: Result of a verification of a private address against a given IRK.
                                                         *     + Event payload: \ref smTbCheckResolvablePrivateAddrResParams_t
                                                         *     + Response to a \ref gBleSmCmdTbCheckResolvablePrivateAddrReq_c command. */
    gBleSmEventTbSignDataRes_c                  = 0x12, /*!< SM Tool Box: Returns the signature for a data block.
                                                         *     + Event payload: \ref smTbSignDataResParams_t
                                                         *     + Response to a \ref gBleSmCmdTbSignDataReq_c command. */
    gBleSmEventTbVerifyDataSignatureRes_c       = 0x13, /*!< SM Tool Box: Result of the verification of the signature of a data block..
                                                         *     + Event payload: \ref smTbVerifyDataSignatureResParams_t
                                                         *     + Response to a \ref gBleSmCmdTbVerifyDataSignatureReq_c command. */
#if (gBLE42_d == TRUE)
    gBleSmEventRemoteKeypressNotification_c     = 0x14, /*!< Event sent to signal a remote SMP Keypress Notification which can be received during Passkey Entry Pairing Method
                                                         *     + Event payload: \ref smKeypressNotificationParams_t */
    gBleSmEventNcDisplayRequest_c               = 0x15, /*!< Event sent to display and confirm a Numeric Comparison Value when using the
                                                         *   LE SC Numeric Comparison pairing method. The user must check and confirm the Numeric Comparison value on both pairing devices.
                                                         *     + Event payload: \ref smNcDisplayReqParams_t
                                                         *     + Expected response: \ref gBleSmCmdNcDisplayConfirm_c command */
    gBleSmEventLeScOobDataRequest_c             = 0x16, /*!< Event sent to the host by the SM to request LE SC OOB Data (r, Cr and Addr) received from a peer
                                                         *   when using the LE SC OOB pairing method and the local device has signalled in the Pairing Request or
                                                         *     + Pairing Response packet that is has obtained or can obtain OOB data from the peer.
                                                         *     + Event payload: none
                                                         *     + Expected response: \ref gBleSmCmdLeScOobDataRequestReply_c command */
    gBleSmEventLocalLeScOobData_c               = 0x17, /*!< Event sent to the host by the SM to provide local LE SC OOB Data (r, Cr and Addr) to be sent to a peer.
                                                         *   This data is used during the LE SC OOOB pairing method. This data can be exchanged through an out-of-band
                                                         *   method before the pairing procedure is started or even before the devices are connected through BLE.
                                                         *   The address parameter will be all zeroes if it is not known by the host stack at the time of the request.
                                                         *   This event always returns an invalid Device Id, it is not related to any device.
                                                         *     + Event payload: \ref smLeScOobDataParams_t
                                                         *     + Response to a \ref gBleSmCmdLocalLeScOobDataRequest_c command */
    gBleSmEventGenerateNewEcdhPkSkPairRes_c     = 0x18, /*!< Result of the generation of a new ECDH Public Key - Secret Key pair.
                                                         *   This event always returns an invalid Device Id, it is not related to any device.
                                                         *     + Event payload: \ref smGenerateNewEcdhPkSkPairResParams_t
                                                         *     + Response to a \ref gBleSmCmdGenerateNewEcdhPkSkPairReq_c command. */
#endif /* (gBLE42_d == TRUE) */
    gBleSmLastEventCode_c                       ,       /*!< Event code used to mark the end of valid command codes. Used only for parameter validation. */
} bleSmEvent_t;

/*! *********************************************************************************
* Security Manager callback function type for sending events to upper layers.
* The callback must be installed by upper layers through the SM Initialization function
* or through the dedicated function.
*
* \param[in]  sourceDevId  Device Id corresponding to the event.
*
* \param[in]  eventType  Type of the of the event. See the \ref bleSmEvent_t enumeration.
*
* \param[in]  eventLength  Length of the event message.
*
* \param[in]  pEventPayload  Pointer to the payload of the event.
*
* \return  Returns the status of the message sending operation.
*
********************************************************************************** */
typedef bleResult_t (*fpSmUserEventCB_t) (deviceId_t    sourceDevId,
                                          bleSmEvent_t  eventType,
                                          uint16_t      eventLength,
                                          void*         pEventPayload);


/************************************************************************************
*************************************************************************************
* Public functions
*************************************************************************************
************************************************************************************/

/*! *********************************************************************************
* \brief  BLE Security Manager initialization function.
*
* \param[in]  userEventCB  Callback function pointer used by the SM to send messages to
*                          the upper layer. This parameter can be NULL.
*
* \return  Returns the status of the init operation (\ref bleResult_t).
*
* \remarks  Must be called when initializing the stack. This function will register
*           an upper layer callback if provided and not NULL.
*
* \retval  gBleResSmNullCBFunction_c The upper layer callback function pointer is null.
*
********************************************************************************** */
bleResult_t Sm_Init (fpSmUserEventCB_t userEventCB);


/*! *********************************************************************************
* \brief  BLE Security Manager function for registering an upper layer callback.
*
* \param[in]  userEventCB  Callback function pointer used by the SM to send events to
*                          the upper layer. If this parameter is NULL the SM will
*                          stop sending messages to the upper layer.
*
* \return  Returns the status of the operation (\ref bleResult_t).
*          Always returns a success status.
*
* \remarks  The callback can also be set up as a parameter to the Security Manager
*           initialization function.
*
********************************************************************************** */
bleResult_t Sm_RegisterUserCallback (fpSmUserEventCB_t userEventCB);


/*! *********************************************************************************
* \brief  Function used by the upper layers to send commands to the Security Manager.
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  cmdCode  Type of the of the command. See the \ref bleSmCommand_t enumeration.
*
* \param[in]  cmdLength  Length of the command.
*
* \param[in]  pCmdPayload  Pointer to the payload of the command.
*
* \return  Returns the status of the command sending operation. Return type is \ref bleResult_t and
*          the values returned start from the \ref gSmStatusBase_c value.
*
********************************************************************************** */
bleResult_t Sm_SendCmd (deviceId_t      destDevId,
                        bleSmCommand_t  cmdCode,
                        uint16_t        cmdLength,
                        void*           pCmdPayload);


/*! *********************************************************************************
* \brief  Initiate the SMP pairing procedure on a Central (Master). A SMP Pairing Request
*         with the provided parameters will be sent to a Peripheral (Slave) device
*         identified by the Device Id.
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smPairingParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#define Sm_InitiatorStartPairing(destDevId, pParams)            \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdInitiatorStartPairing_c,           \
                    sizeof(smPairingParams_t),                  \
                    (void*)(pParams))


/*! *********************************************************************************
* \brief  Send a SMP security request from a Peripheral (Slave) device
*         to a Central (Master) device.
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smSecurityReqParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#define Sm_SendSecurityRequest(destDevId, pParams)              \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdSendSecurityRequest_c,             \
                    sizeof(smSecurityReqParams_t),              \
                    (void*)(pParams))


/*! *********************************************************************************
* \brief  Send a SM pairing termination request providing a reason.
*         Not all reasons are valid in all SM contexts. An appropriate status is
*         returned if the reason is unexpected in the current state.
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smTerminatePairingParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#define Sm_TerminatePairing(destDevId, pParams)                 \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdTerminatePairing_c,                \
                    sizeof(smTerminatePairingParams_t),         \
                    (void*)(pParams))


/*! *********************************************************************************
* \brief  Respond to a remote pairing request with the parameters required
*         for the pairing procedure.
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smPairingParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#define Sm_PairingRequestReply(destDevId, pParams)              \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdPairingRequestReply_c,             \
                    sizeof(smPairingParams_t),                  \
                    (void*)(pParams))


/*! *********************************************************************************
* \brief  Respond to a Passkey Request Event from the SM with
*         the passkey (0 to 999999 decimal or 16 bytes OOB)
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smPasskeyReqReplyParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#define Sm_PasskeyRequestReply(destDevId, pParams)              \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdPasskeyRequestReply_c,             \
                    sizeof(smPasskeyReqReplyParams_t),          \
                    (void*)(pParams))


/*! *********************************************************************************
* \brief  Respond to a Pairing Keyset Request Event from the SM with
*         the keyset and additional data.
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smPairingKeysetRequestReplyParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#define Sm_PairingKeysetRequestReply(destDevId, pParams)            \
        Sm_SendCmd ((destDevId),                                    \
                    gBleSmCmdPairingKeysetRequestReply_c,           \
                    sizeof(smPairingKeysetRequestReplyParams_t),    \
                    (void*)(pParams))


/*! *********************************************************************************
* \brief  Start the encryption of the Link Layer connection to the specified device.
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smLlStartEncryptionParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#if (gSmpInitiatorSupported_d == 1U)
#define Sm_LlStartEncryption(destDevId, pParams)                \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdLlStartEncryption_c,               \
                    sizeof(smLlStartEncryptionParams_t),        \
                    (void*)(pParams))
#endif

/*! *********************************************************************************
* \brief  Respond to a Link Layer LTK request for the encryption of the connection to
*         the specified device.
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smLlLtkRequestReplyParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#if (gSmpResponderSupported_d == 1)
#define Sm_LlLtkRequestReply(destDevId, pParams)                \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdLlLtkRequestReply_c,               \
                    sizeof(smLlLtkRequestReplyParams_t),        \
                    (void*)(pParams))
#endif

/*! *********************************************************************************
* \brief  Reject a Link Layer LTK request.
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command does not have any parameters.
*
********************************************************************************** */
#if (gSmpResponderSupported_d == 1)
#define Sm_LlLtkRequestNegativeReply(destDevId)                 \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdLlLtkRequestNegativeReply_c,       \
                    0U,                                          \
                    (void*)NULL)
#endif

/*! *********************************************************************************
* \brief  Request an AES-128 encryption of a 128 bit block providing a 128 bit key.
*
* \param[in]  pParams  Pointer to a structure of \ref smLlEncryptReqParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  If the host has AES-128 hardware support no HCI calls are made for
*           the encryption operation and the result is returned immediately.
*           This command is not intended for a specific device.
*
********************************************************************************** */
#if defined(gHciLeEncryptSupport_d) && (gHciLeEncryptSupport_d == TRUE)
#define Sm_LlEncryptRequest(pParams)                            \
        Sm_SendCmd (0U,                                          \
                    gBleSmCmdLlEncryptReq_c,                    \
                    sizeof(smLlEncryptReqParams_t),             \
                    (void*)(pParams))
#endif

/*! *********************************************************************************
* \brief  Request the generation of a 64 bit random number.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  If the host has RNG hardware support no HCI calls are made for
*           the random number generation operation and the result is returned
*           immediately.
*           This command is not intended for a specific device.
*           This command does not have any parameters.
*
********************************************************************************** */
#if defined(gHciLeRandomSupport_d) && (gHciLeRandomSupport_d == TRUE)
#define Sm_LlRandRequest()                                      \
        Sm_SendCmd (0U,                                          \
                    gBleSmCmdLlRandReq_c,                       \
                    0U,                                          \
                    (void*)NULL)
#endif

/*! *********************************************************************************
* \brief  Request the creation of a BLE random device Address.
*
* \param[in]  pParams  Pointer to a structure of \ref smTbCreateRandomDeviceAddrReqParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command is not intended for a specific device.
*
********************************************************************************** */
#define Sm_TbCreateRandomDeviceAddressRequest(pParams)              \
        Sm_SendCmd (0U,                                              \
                    gBleSmCmdTbCreateRandomDeviceAddrReq_c,         \
                    sizeof(smTbCreateRandomDeviceAddrReqParams_t),  \
                    (void*)(pParams))


/*! *********************************************************************************
* \brief  Request to check a Resolvable Private Address against an IRK.
*
* \param[in]  pParams  Pointer to a structure of \ref smTbCheckResolvablePrivateAddrReqParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command is not intended for a specific device.
*
********************************************************************************** */
#define Sm_TbCheckResolvablePrivateAddressRequest(pParams)              \
        Sm_SendCmd (0U,                                                  \
                    gBleSmCmdTbCheckResolvablePrivateAddrReq_c,         \
                    sizeof(smTbCheckResolvablePrivateAddrReqParams_t),  \
                    (void*)(pParams))


/*! *********************************************************************************
* \brief  Request to calculate an Authentication Signature for a block of data
*         using a provided CSRK.
*
* \param[in]  pParams  Pointer to a structure of \ref smTbSignDataReqParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command is not intended for a specific device.
*
********************************************************************************** */
#if (gGattClientSupported_d == 1)
#define Sm_TbSignDataRequest(pParams)                           \
        Sm_SendCmd (0U,                                          \
                    gBleSmCmdTbSignDataReq_c,                   \
                    sizeof(smTbSignDataReqParams_t),            \
                    (void*)(pParams))
#endif

/*! *********************************************************************************
* \brief  Request to verify an Authentication Signature for a block of data
*         using a provided CSRK.
*
* \param[in]  pParams  Pointer to a structure of \ref smTbVerifyDataSignatureReqParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command is not intended for a specific device.
*
********************************************************************************** */
#if (gGattServerSupported_d == 1)
#define Sm_TbVerifyDataSignatureRequest(pParams)                \
        Sm_SendCmd (0U,                                          \
                    gBleSmCmdTbVerifyDataSignatureReq_c,        \
                    sizeof(smTbVerifyDataSignatureReqParams_t), \
                    (void*)(pParams))
#endif

/*! *********************************************************************************
* \brief  Send a Device Connection Notification to the SM when a LL connection
*         is created with the specified device.
*
* \param[in]  destDevId  Device Id.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command does not have any parameters.
*
********************************************************************************** */
#define Sm_DeviceConnectNotification(destDevId)                 \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdDevConnectNotification_c,          \
                    0U,                                          \
                    (void*)NULL)

/*! *********************************************************************************
* \brief  Send a Device Disconnection Notification to the SM when the LL connection
*         with the specified device is terminated.
*
* \param[in]  destDevId  Device Id.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command does not have any parameters.
*
********************************************************************************** */
#define Sm_DeviceDisconnectNotification(destDevId)              \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdDevDisconnectNotification_c,       \
                    0U,                                          \
                    (void*)NULL)

/*! *********************************************************************************
* \brief  Set a default passkey in the SM.
*
* \param[in]  pParams  Pointer to a structure of \ref smSetDefaultPasskeyParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command is not intended for a specific device.
*
********************************************************************************** */
#define Sm_SetDefaultPasskey(pParams)                           \
        Sm_SendCmd (0U,                                          \
                    gBleSmCmdSetDefaultPasskey_c,               \
                    sizeof(smSetDefaultPasskeyParams_t),        \
                    (void*)(pParams))

#if (gBLE42_d == TRUE)
/*! *********************************************************************************
* \brief  Set the MITM protection property of the OOB pairing method and resulting
*         security material (starting with BLE 4.2 OOB Data may or may not have MITM protection)
*
* \param[in]  pParams  Pointer to a structure of \ref smSetOobMitmProtectionParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command is not intended for a specific device.
*
********************************************************************************** */
#define Sm_SetOobMitmProtection(pParams)                        \
        Sm_SendCmd (0U,                                          \
                    gBleSmCmdSetOobMitmProtection_c,            \
                    sizeof(smSetOobMitmProtectionParams_t),     \
                    (void*)(pParams))

/*! *********************************************************************************
* \brief  Send a Keypress Notification to a peer device during pairing using the
*         Passkey Entry Pairing Method
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smKeypressNotificationParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#define Sm_SendKeypressNotification(destDevId, pParams)         \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdSendKeypressNotification_c,        \
                    sizeof(smKeypressNotificationParams_t),     \
                    (void*)(pParams))

/*! *********************************************************************************
* \brief  Send a Numeric Comparison Display Confirm to the SM during pairing using the
*         LE SC Numeric Comparison Pairing Method
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smNcDisplayConfirmParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#define Sm_NcDisplayConfirm(destDevId, pParams)                 \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdNcDisplayConfirm_c,                \
                    sizeof(smNcDisplayConfirmParams_t),         \
                    (void*)(pParams))

/*! *********************************************************************************
* \brief  Send a LE SC OOB Data Request Reply to the SM containing LE SC OOB Data
*         of a peer when pairing using the LE SC OOB Pairing Method
*
* \param[in]  destDevId  Device Id of the destination device.
*
* \param[in]  pParams  Pointer to a structure of \ref smLeScOobDataParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
********************************************************************************** */
#define Sm_LeScOobDataRequestReply(destDevId, pParams)          \
        Sm_SendCmd ((destDevId),                                \
                    gBleSmCmdLeScOobDataRequestReply_c,         \
                    sizeof(smLeScOobDataParams_t),              \
                    (void*)(pParams))

/*! *********************************************************************************
* \brief  Request the local LE SC OOB data to be sent to a peer device via an out-of-band
*         channel when pairing using the LE SC OOB Pairing Method
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command is not intended for a specific device.
*           This command does not have any parameters.
*
********************************************************************************** */
#define Sm_LocalLeScOobDataRequest()                            \
        Sm_SendCmd (0U,                                          \
                    gBleSmCmdLocalLeScOobDataRequest_c,         \
                    0U,                                          \
                    (void*)NULL)

/*! *********************************************************************************
* \brief  Instruct the SM to generate a new ECDH Public Key - Secret Key pair.
*         The LE SC OOB r and Cr values will also be regenerated because the
*         LE SC OOB Cr value depends on the Public Key.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command is not intended for a specific device.
*           This command does not have any parameters.
*
********************************************************************************** */
#define Sm_GenerateNewEcdhPkSkPair()                            \
        Sm_SendCmd (0U,                                          \
                    gBleSmCmdGenerateNewEcdhPkSkPairReq_c,      \
                    0U,                                          \
                    (void*)NULL)

#endif /* (gBLE42_d == TRUE) */

/*! *********************************************************************************
* \brief  Set the minimum acceped security properties accepted by the SM for the
*         SMP Pairing Procedure (MITM, SC, Minimum Key Size)
*
* \param[in]  pParams  Pointer to a structure of \ref smSetMinPairingSecurityPropertiesParams_t type.
*
* \return  Returns the status of the operation. Return type is \ref bleResult_t.
*
* \remarks  This command is not intended for a specific device.
*
********************************************************************************** */
#define Sm_SetMinPairingSecurityProperties(pParams)                     \
        Sm_SendCmd (0U,                                                  \
                    gBleSmCmdSetMinPairingSecurityProperties_c,         \
                    sizeof(smSetMinPairingSecurityPropertiesParams_t),  \
                    (void*)(pParams))

#endif /* SM_INTERFACE_H */

/*! *********************************************************************************
* @}
********************************************************************************** */
